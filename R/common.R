#########################################################################
#     Raman2imzML - Reinshaws raman data in .txt format converter to 
#                    imzML using rMSI's imzML creator source code.
#
#     Copyright (C) 2020 Lluc Semente Fernandez
#
#     This program is free software: you can redistribute it and/or modify
#     it under the terms of the GNU General Public License as published by
#     the Free Software Foundation, either version 3 of the License, or
#     (at your option) any later version.
#
#     This program is distributed in the hope that it will be useful,
#     but WITHOUT ANY WARRANTY; without even the implied warranty of
#     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#     GNU General Public License for more details.
#
#     You should have received a copy of the GNU General Public License
#     along with this program.  If not, see <http://www.gnu.org/licenses/>.
############################################################################


#' Read clean data, generates the binary file and computes the hash. 
#' 
#' @param imzML_path path to the folder where the imzML file is going to be stored.
#' @param file_name name of the txt file or a new name.(currently the converter just copies the txt file name) 
#' @param clean_data rearranged data structure.
#' @param uuid uuid. This code must be shared between the imzMl file and the ibd file. 
#' 
#' @return  List containing the sha and the md5 of the ibd file.
#' 
write_ibd <- function(imzML_path, file_name, clean_data, uuid)
{
  ibd_path <- paste(path.expand(imzML_path),file_name,".ibd",sep = "")
  intUUID <- strtoi(substring(uuid, seq(1,nchar(uuid),2), seq(2,nchar(uuid),2)), base = 16)
  
  if (file.create(ibd_path))
  {
    pb <- txtProgressBar(min = 0, max = nrow(clean_data$intensity), initial = 0, style = 3)
    iPixel <- 0
    setTxtProgressBar(pb, iPixel)
    ibd_conn <- file(ibd_path, "wb")
    writeBin(intUUID, ibd_conn, size = 1, endian = "little") #write UUID
    writeBin(clean_data$ramanShift, ibd_conn, size = 4, endian = "little", useBytes = T) #write raman shift axis
    for(pixel in 1:nrow(clean_data$intensity))
    {
      iPixel <- iPixel + 1
      setTxtProgressBar(pb, iPixel)
      writeBin(clean_data$intensity[pixel,], ibd_conn, size = 4, endian = "little", useBytes = T) #write each pixel
    }
    sha <- digest::digest(ibd_conn, algo = "sha1")
    close(ibd_conn)
    close(pb)
  } else(stop("File could not be created"))
  
  return(list(sha = sha))
}


#' Generates the offset matrix.
#' 
#' @param clean_data path to the .txt file.
#'
#' @return  an offset matrix.
#' 
clean_2_offsetMatrix <- function(clean_data)
{
  # Create the offset matrix
  offMat <- list()
  offMat$UUID <- clean_data$hash$uuid
  offMat$SHA <- clean_data$hash$sha
  offMat$MD5 <- ""
  offMat$continuous_mode <- TRUE
  offMat$compression_mz <- FALSE
  offMat$compression_int <- FALSE
  offMat$mz_dataType <- "float"
  offMat$int_dataType <- "float"
  offMat$pixel_size_um <- clean_data$pixelSize
  offMat$run_data <- data.frame(x = clean_data$pos$x,
                                y = clean_data$pos$y,
                                mzLength = rep(length(clean_data$ramanShift), length(clean_data$pos$x)),
                                mzOffset = rep(16, length(clean_data$pos$x)),
                                intLength = rep(length(clean_data$ramanShift), length(clean_data$pos$x)),
                                intOffset =  16+(length(clean_data$ramanShift)*4)+(4*length(clean_data$ramanShift)*(0:(length(clean_data$pos$x) - 1)))
  )
  return(offMat)
}


#' Generates the uuid number.
#' 
#' Generates a timecode-based 16-bytes UUID.
#' The generated bytes are generated using the following pattern:
#' bytes 0 and 1: Year
#' byte 2: Month
#' byte 3: Day
#' byte 4: Hour
#' byte 5: Minute
#' byte 6: Second
#' bytes 7 to 15: random.
#'
#' @return a uuid in a text string.
#'
uuid_timebased <- function()
{
  currentTime <- Sys.time()
  sUUID <- sprintf( "%04X", as.integer( format(currentTime, "%Y")))
  sUUID <- paste0( sUUID, sprintf( "%02X", as.integer( format(currentTime, "%m"))))
  sUUID <- paste0( sUUID, sprintf( "%02X", as.integer( format(currentTime, "%d"))))
  sUUID <- paste0( sUUID, sprintf( "%02X", as.integer( format(currentTime, "%H"))))
  sUUID <- paste0( sUUID, sprintf( "%02X", as.integer( format(currentTime, "%M"))))
  sUUID <- paste0( sUUID, sprintf( "%02X", as.integer( format(currentTime, "%S"))))
  sUUID <-paste0(sUUID, paste0(sprintf("%02X",sample(0:255, 9)), collapse = ""))
  
  return(sUUID)
}


